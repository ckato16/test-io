<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pitch Trainer</title>
<style>
body {
  font-family: sans-serif;
  text-align: center;
  background: #f0f0f0;
}
h1 { margin-top: 20px; }
button { margin: 5px; padding: 5px 10px; font-size: 16px; }
#status { font-size: 20px; margin-top: 20px; }

#keyboardContainer {
  display: flex;
  justify-content: center;
  margin-top: 20px;
  overflow-x: auto;
  padding: 10px;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}
.keyboard {
  display: flex;
  position: relative;
  flex-shrink: 0;
  height: 200px;
  width: 100%;
  max-width: 600px;
}
.white-key {
  flex: 1 0 auto;
  min-width: 30px;
  height: 200px;
  position: relative;
  background: white;
  border: 1px solid black;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;
  padding-bottom: 6px;
  font-size: 12px;
  cursor: pointer;
  box-sizing: border-box;
}
.white-key.active { background: #d0f0d0; }
.white-key.mic-detect { background: red; }
.black-key {
  position: absolute;
  top: 0;
  height: 60%;
  background: black;
  border-radius: 0 0 3px 3px;
  cursor: pointer;
  z-index: 2;
}
.black-key.active { background: #444; }
.black-key.mic-detect { background: red; }
</style>
</head>
<body>

<h1>Pitch Trainer ðŸŽ¶</h1>

<button id="startBtn">Start</button>
<button id="replayBtn">Replay</button>
<p id="status">Press "Start"!</p>

<div id="keyboardContainer">
  <div class="keyboard" id="keyboard"></div>
</div>

<script>
// ---------------- SETTINGS ----------------
const octaves = [3,4,5];
const semitones = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
let notes = [];
octaves.forEach(o => semitones.forEach(s => notes.push(s+o)));

const noteFrequencies = {};
notes.forEach(n => {
  const octave = parseInt(n.replace(/\D/g,''));
  const semitoneOffsets = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
  noteFrequencies[n] = 16.35 * Math.pow(2, octave + semitoneOffsets[n.replace(/\d/,'')] / 12);
});

let currentNote = null;
let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const testRange = {min:'C3', max:'B4'};
let acceptingPitch = false;

// ---------------- AUDIO ----------------
function playNote(note, duration=0.5){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain).connect(audioCtx.destination);
  osc.frequency.value = noteFrequencies[note];
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.start();
  osc.stop(audioCtx.currentTime+duration);
}

// ---------------- KEYBOARD ----------------
const keyboardDiv = document.getElementById('keyboard');
let keyElements = {};

function createKeyboard() {
  keyboardDiv.innerHTML = '';
  keyElements = {};

  const displayNotes = notes.slice(
    notes.indexOf(testRange.min),
    notes.indexOf(testRange.max) + 1
  );

  // --- create white keys ---
  const whiteKeys = displayNotes.filter(n => !n.includes('#'));
  whiteKeys.forEach(n => {
    const key = document.createElement('div');
    key.className = 'white-key';
    key.dataset.note = n;
    key.textContent = n;
    key.addEventListener('click', () => {
      if (!acceptingPitch) return;
      playNote(n);
      handleUserGuess(n);
    });
    keyboardDiv.appendChild(key);
    keyElements[n] = key;
  });

  // --- create black keys ---
  displayNotes.forEach((n, i) => {
    if (n.includes('#')) {
      const prevWhite = displayNotes.slice(0, i).reverse().find(nn => !nn.includes('#'));
      if (prevWhite) {
        const key = document.createElement('div');
        key.className = 'black-key';
        key.dataset.note = n;
        key.addEventListener('click', () => {
          if (!acceptingPitch) return;
          playNote(n);
          handleUserGuess(n);
        });
        keyboardDiv.appendChild(key);
        keyElements[n] = key;
      }
    }
  });

  positionBlackKeys();
}

function positionBlackKeys() {
  Object.values(keyElements).forEach(k => {
    if (k.classList.contains('black-key')) {
      const note = k.dataset.note;
      const i = notes.indexOf(note);
      const prevWhite = notes.slice(0, i).reverse().find(nn => !nn.includes('#'));
      if (prevWhite) {
        const whiteKey = keyElements[prevWhite];
        const whiteWidth = whiteKey.offsetWidth;

        k.style.width = (whiteWidth * 0.6) + 'px';                 // scale black key
        k.style.left = (whiteKey.offsetLeft + whiteWidth * 0.7) + 'px'; // position black key
      }
    }
  });
}

window.addEventListener('resize', () => {
  positionBlackKeys();
});

createKeyboard();

function positionBlackKeys() {
  Object.values(keyElements).forEach(k => {
    if (k.classList.contains('black-key')) {
      const note = k.dataset.note;
      const i = notes.indexOf(note);
      const prevWhite = notes.slice(0, i).reverse().find(nn => !nn.includes('#'));
      if (prevWhite) {
        const whiteKey = keyElements[prevWhite];
        const whiteWidth = whiteKey.offsetWidth;
        k.style.width = (whiteWidth * 0.6) + 'px';          // scale width
        k.style.left = (whiteKey.offsetLeft + whiteWidth * 0.7) + 'px';  // reposition
      }
    }
  });
}

positionBlackKeys();

// ---------------- GAME LOGIC ----------------
const startBtn = document.getElementById('startBtn');
const replayBtn = document.getElementById('replayBtn');

startBtn.addEventListener('click', startGame);
replayBtn.addEventListener('click', replayNote);
replayBtn.disabled = true;

function startGame(){
  currentNote=null;
  const rangeNotes = notes.slice(notes.indexOf(testRange.min), notes.indexOf(testRange.max)+1);
  currentNote = rangeNotes[Math.floor(Math.random()*rangeNotes.length)];
  document.getElementById('status').textContent=`Listen...`;
  acceptingPitch = false;
  setTimeout(()=>{
    playNote(currentNote,0.5);
    setTimeout(()=>{
      acceptingPitch = true;
      document.getElementById('status').textContent=`Click or sing the note!`;
      replayBtn.disabled = false;
    }, 500);
  }, 200);
}

function replayNote(){
    document.getElementById('status').textContent=`Listen...`;
    acceptingPitch = false;
    playNote(currentNote,0.5);
    setTimeout(()=>{
      document.getElementById('status').textContent=`Click or sing the note!`;
      acceptingPitch = true;
    }, 500);
}

function handleUserGuess(note){
  if(!acceptingPitch) return;
  flashKey(note);
  if(note===currentNote){
    document.getElementById('status').textContent=`âœ… Correct! It was ${currentNote}!`;
  } else {
    document.getElementById('status').textContent=`âŒ Wrong! It was ${currentNote} not ${note}!`;
  }
  //acceptingPitch = false;
  //currentNote=null;
  //replayBtn.disabled = true;
}

function flashKey(note){
  const key = keyElements[note];
  if(key){ key.classList.add('active'); setTimeout(()=>key.classList.remove('active'),300); }
}

// ---------------- MICROPHONE PITCH DETECTION ----------------
let analyser, dataArray, source;
let pitchBuffer = [];
const HOLD_FRAMES = 30; // ~0.5 sec (assuming 60fps)

navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  source = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  source.connect(analyser);
  dataArray = new Float32Array(analyser.fftSize);
  detectPitch();
});

function autoCorrelate(buffer, sampleRate){
  let SIZE = buffer.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++) rms += buffer[i]*buffer[i];
  rms = Math.sqrt(rms/SIZE);
  if(rms<0.01) return -1;
  let r=[];
  for(let i=0;i<SIZE;i++) r[i]=0;
  for(let lag=0;lag<SIZE;lag++){
    for(let i=0;i<SIZE-lag;i++) r[lag]+=buffer[i]*buffer[i+lag];
  }
  let d=0; while(r[d]>r[d+1]) d++;
  let maxval=-1, maxpos=-1;
  for(let i=d;i<SIZE;i++){
    if(r[i]>maxval){ maxval=r[i]; maxpos=i; }
  }
  let T0 = maxpos;
  return sampleRate/T0;
}

function detectPitch(){
  analyser.getFloatTimeDomainData(dataArray);
  const pitch = autoCorrelate(dataArray,audioCtx.sampleRate);

  Object.values(keyElements).forEach(k=>k.classList.remove('mic-detect'));

  if(pitch>0 && acceptingPitch){
    let closestNote=null; let minDiff=Infinity;
    for(let n in noteFrequencies){
      if(notes.indexOf(n) >= notes.indexOf(testRange.min) &&
         notes.indexOf(n) <= notes.indexOf(testRange.max)){
        const diff = Math.abs(noteFrequencies[n]-pitch);
        if(diff<minDiff){ minDiff=diff; closestNote=n; }
      }
    }

    if(closestNote){
      keyElements[closestNote].classList.add('mic-detect');
      pitchBuffer.push(closestNote);
      if(pitchBuffer.length > HOLD_FRAMES) pitchBuffer.shift(); 
      const lastNote = pitchBuffer[pitchBuffer.length-1];
      const allSame = pitchBuffer.every(n => n===lastNote);
      if(allSame && pitchBuffer.length>=HOLD_FRAMES){
        handleUserGuess(lastNote);
        pitchBuffer = [];
      }
    } else pitchBuffer = [];
  } else pitchBuffer = [];

  requestAnimationFrame(detectPitch);
}
</script>

</body>
</html>
