<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chord Trainer</title>
<style>
body {
  font-family: sans-serif;
  text-align: center;
  background: #f0f0f0;
}
h1 { margin-top: 20px; }
button { margin: 5px; padding: 5px 10px; font-size: 16px; }
#status { font-size: 18px; margin-top: 15px; }

#keyboardContainer {
  display: flex;
  justify-content: center;
  margin-top: 20px;
  overflow-x: auto;
  padding: 10px;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.keyboard {
  display: flex;
  position: relative;
  flex-shrink: 0;
  height: 200px;
  width: 100%;
  max-width: 600px;
}

.white-key {
  flex: 1 0 auto;
  min-width: 30px;
  height: 200px;
  position: relative;
  background: white;
  border: 1px solid black;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;
  padding-bottom: 6px;
  font-size: 12px;
  cursor: pointer;
  box-sizing: border-box;
}
.white-key.active { background: #d0f0d0; }
.white-key.mic-detect { background: red; }

.black-key {
  position: absolute;
  top: 0;
  height: 60%;
  background: black;
  border-radius: 0 0 3px 3px;
  cursor: pointer;
  z-index: 2;
}
.black-key.active { background: #444; }
.black-key.mic-detect { background: red; }

#controls { margin-top: 20px; }
#setups {
  display: inline-flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 5px;
  margin: 20px auto;
}
</style>
</head>
<body>

<h1>Chord Trainer ðŸŽ¶</h1>

Setup:<br>

<div id="setups">
  <label><input type="checkbox" id="arpeggioMode"> Arpeggio Mode</label>
  <label><input type="checkbox" class="category" value="power" checked> Power (0,7)</label>
  <label><input type="checkbox" class="category" value="major"> Major (0,4,7)</label>
  <label><input type="checkbox" class="category" value="minor"> Minor (0,3,7)</label>
  <label><input type="checkbox" class="category" value="sus2"> Sus2 (0,2,7)</label>
  <label><input type="checkbox" class="category" value="sus4"> Sus4 (0,5,7)</label>
  <label><input type="checkbox" class="category" value="aug"> Augmented (0,4,8)</label>
  <label><input type="checkbox" class="category" value="dim"> Diminished (0,3,6)</label>
  <label><input type="checkbox" class="category" value="maj7"> Major 7th (0,4,7,11)</label>
  <label><input type="checkbox" class="category" value="min7"> Minor 7th (0,4,7,10)</label>
  <label><input type="checkbox" class="category" value="add9"> Add9 (0,4,7,14)</label>
</div>

<p id="status">Press "Start"!</p>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="replayBtn">Replay</button>
  <button id="deleteBtn">Delete</button>
  <button id="submitBtn">Submit</button>
</div>

<p id="selectedNotes">Selected: </p>

<div id="keyboardContainer">
  <div class="keyboard" id="keyboard"></div>
</div>

<script>
// ---------------- SETTINGS ----------------
const octaves = [3,4];
const semitones = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
let notes = [];
octaves.forEach(o => semitones.forEach(s => notes.push(s+o)));

const noteFrequencies = {};
notes.forEach(n => {
  const octave = parseInt(n.replace(/\D/g,''));
  const semitoneOffsets = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
  noteFrequencies[n] = 16.35 * Math.pow(2, octave + semitoneOffsets[n.replace(/\d/,'')] / 12);
});

let currentChord = null;
let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let acceptingPitch = false;
let selectedNotes = [];
const minNote = 'C3';
const maxNote = 'B4';

// ---------------- AUDIO ----------------
function playNote(note, duration=0.5){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain).connect(audioCtx.destination);
  osc.frequency.value = noteFrequencies[note];
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.start();
  osc.stop(audioCtx.currentTime+duration);
}

// ---------------- KEYBOARD ----------------
const keyboardDiv = document.getElementById('keyboard');
let keyElements = {};

function createKeyboard(){
  keyboardDiv.innerHTML='';
  keyElements = {};
  const displayNotes = notes.slice(notes.indexOf(minNote), notes.indexOf(maxNote)+1);

  // create white keys
  let whiteKeys = displayNotes.filter(n=>!n.includes('#'));
  whiteKeys.forEach(n=>{
    const key = document.createElement('div');
    key.className='white-key';
    key.dataset.note=n;
    key.textContent=n;
    key.addEventListener('click',()=>{ 
      playNote(n);
      if(acceptingPitch && !selectedNotes.includes(n)){
        selectedNotes.push(n);
        updateSelectedNotes();
      }
    });
    keyboardDiv.appendChild(key);
    keyElements[n]=key;
  });

  // create black keys
  displayNotes.forEach((n,i)=>{
    if(n.includes('#')){
      const prevWhite = displayNotes.slice(0,i).reverse().find(nn=>!nn.includes('#'));
      if(prevWhite){
        const key = document.createElement('div');
        key.className='black-key';
        key.dataset.note=n;
        const whiteKey = keyElements[prevWhite];
        key.style.left = (whiteKey.offsetLeft + whiteKey.offsetWidth*0.65) + 'px';
        key.style.width = (whiteKey.offsetWidth*0.65) + 'px'; // scale black key width
        key.style.height = (whiteKey.offsetHeight*0.65) + 'px'; // scale black key height
        key.addEventListener('click',()=>{ 
          playNote(n);
          if(acceptingPitch && !selectedNotes.includes(n)){
            selectedNotes.push(n);
            updateSelectedNotes();
          }
        });
        keyboardDiv.appendChild(key);
        keyElements[n]=key;
      }
    }
  });
}
createKeyboard();

function updateSelectedNotes(){
  const sorted = selectedNotes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  document.getElementById('selectedNotes').textContent = 'Selected: ' + sorted.join(', ');
}

// ---------------- CHORDS ----------------
const chordPatterns = {
  power: [[0,7]],
  major: [[0,4,7]],
  minor: [[0,3,7]],
  sus2: [[0,2,7]],
  sus4: [[0,5,7]],
  aug: [[0,4,8]],
  dim: [[0,3,6]],
  maj7: [[0,4,7,11]],
  min7: [[0,3,7,10]],
  add9: [[0,4,7,14]]
};

function isChordInRange(chordNotes){
  return chordNotes.every(n => notes.indexOf(n)>=notes.indexOf(minNote) && notes.indexOf(n)<=notes.indexOf(maxNote));
}

function generateChord(){
  const categories = Array.from(document.querySelectorAll('.category:checked')).map(c=>c.value);
  if(categories.length===0) return null;

  let chord = null;
  let attempt=0;
  while(!chord && attempt<100){
    attempt++;
    const category = categories[Math.floor(Math.random()*categories.length)];
    const rootNotes = notes.slice(notes.indexOf(minNote), notes.indexOf(maxNote)+1);
    const root = rootNotes[Math.floor(Math.random()*rootNotes.length)];
    const intervals = chordPatterns[category][0];
    const chordNotes = intervals.map(i=> notes[notes.indexOf(root)+i]).filter(Boolean);
    if(chordNotes.length===intervals.length && isChordInRange(chordNotes)){
      chord = {root, category, notes: chordNotes};
    }
  }
  return chord;
}

// ---------------- GAME LOGIC ----------------
const startBtn = document.getElementById('startBtn');
const replayBtn = document.getElementById('replayBtn');
const submitBtn = document.getElementById('submitBtn');
const deleteBtn = document.getElementById('deleteBtn');
const arpeggioCheckbox = document.getElementById('arpeggioMode');

startBtn.addEventListener('click', startGame);
replayBtn.addEventListener('click', replayChord);
submitBtn.addEventListener('click', submitAnswer);
deleteBtn.addEventListener('click', ()=>{
  selectedNotes.pop();
  updateSelectedNotes();
});
replayBtn.disabled=true;
deleteBtn.disabled=true;
submitBtn.disabled=true;

function startGame(){
  document.getElementById('status').textContent=`Listen, select, submit...`;
  currentChord = generateChord();
  playChord(currentChord);
  replayBtn.disabled=false;
  deleteBtn.disabled=false;
  submitBtn.disabled=false;
}

function playChord(chord){
  acceptingPitch=false;
  selectedNotes=[];
  updateSelectedNotes();
  const duration = 0.5;
  if(arpeggioCheckbox.checked){
    chord.notes.forEach((n,i)=>{
      setTimeout(()=>playNote(n,duration), i*duration*1000);
    });
    setTimeout(()=>acceptingPitch=true, chord.notes.length*duration*1000);
  } else {
    chord.notes.forEach(n=>playNote(n,duration));
    setTimeout(()=>acceptingPitch=true, duration*1000);
  }
}

function replayChord(){
  document.getElementById('status').textContent=`Listen, select, submit...`;
  playChord(currentChord);
  selectedNotes = []
  replayBtn.disabled=false;
  deleteBtn.disabled=false;
  submitBtn.disabled=false;
}

function submitAnswer(){
  if(!currentChord) return;
  const sortedCorrect = currentChord.notes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  const sortedUser = selectedNotes.slice().sort((a,b)=>notes.indexOf(a)-notes.indexOf(b));
  let correct = sortedCorrect.join(', ');
  let user = sortedUser.join(', ');
  let message;
  if(sortedCorrect.join()===sortedUser.join()){
    message=`âœ… Correct! It was ${currentChord.root} ${currentChord.category} (${correct})!`;
  } else {
    message=`âŒ Wrong! It was ${currentChord.root} ${currentChord.category} (${correct})!`;
  }
  document.getElementById('status').textContent=message;
}

// ---------------- MICROPHONE PITCH DETECTION ----------------
let analyser, dataArray, source, pitchBuffer=[];
const HOLD_FRAMES = 30; // ~0.5s

navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  source = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize=2048;
  source.connect(analyser);
  dataArray = new Float32Array(analyser.fftSize);
  detectPitch();
});

function autoCorrelate(buffer, sampleRate){
  let SIZE = buffer.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++) rms += buffer[i]*buffer[i];
  rms = Math.sqrt(rms/SIZE);
  if(rms<0.01) return -1;
  let r=[];
  for(let i=0;i<SIZE;i++) r[i]=0;
  for(let lag=0;lag<SIZE;lag++){
    for(let i=0;i<SIZE-lag;i++) r[lag]+=buffer[i]*buffer[i+lag];
  }
  let d=0; while(r[d]>r[d+1]) d++;
  let maxval=-1,maxpos=-1;
  for(let i=d;i<SIZE;i++){
    if(r[i]>maxval){ maxval=r[i]; maxpos=i; }
  }
  let T0=maxpos;
  return sampleRate/T0;
}

function detectPitch(){
  analyser.getFloatTimeDomainData(dataArray);
  const pitch = autoCorrelate(dataArray,audioCtx.sampleRate);
  Object.values(keyElements).forEach(k=>k.classList.remove('mic-detect'));

  if(pitch>0 && acceptingPitch){
    let closestNote=null, minDiff=Infinity;
    for(let n in noteFrequencies){
      if(notes.indexOf(n)>=notes.indexOf(minNote) && notes.indexOf(n)<=notes.indexOf(maxNote)){
        const diff=Math.abs(noteFrequencies[n]-pitch);
        if(diff<minDiff){ minDiff=diff; closestNote=n; }
      }
    }
    if(closestNote){
      keyElements[closestNote].classList.add('mic-detect');
      pitchBuffer.push(closestNote);
      if(pitchBuffer.length>HOLD_FRAMES) pitchBuffer.shift();
      const lastNote = pitchBuffer[pitchBuffer.length-1];
      const allSame = pitchBuffer.every(n=>n===lastNote);
      if(allSame && pitchBuffer.length>=HOLD_FRAMES){
        if(!selectedNotes.includes(lastNote)){
          selectedNotes.push(lastNote);
          updateSelectedNotes();
        }
        pitchBuffer=[];
      }
    } else pitchBuffer=[];
  } else pitchBuffer=[];
  requestAnimationFrame(detectPitch);
}

// ---------------- RESIZE BLACK KEYS ON WINDOW RESIZE ----------------
window.addEventListener('resize', ()=> {
  Object.values(keyElements).forEach(k=>{
    if(k.classList.contains('black-key')){
      const prevWhite = notes.slice(notes.indexOf(minNote), notes.indexOf(maxNote)+1)
        .slice(0, notes.indexOf(k.dataset.note))
        .reverse()
        .find(n=>!n.includes('#'));
      if(prevWhite){
        const whiteKey = keyElements[prevWhite];
        k.style.left = (whiteKey.offsetLeft + whiteKey.offsetWidth*0.65)+'px';
        k.style.width = (whiteKey.offsetWidth*0.65)+'px';
        k.style.height = (whiteKey.offsetHeight*0.65)+'px';
      }
    }
  });
});
</script>

</body>
</html>
