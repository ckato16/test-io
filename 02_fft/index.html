<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectrum & Spectrogram Visualizer</title>
<style>
  body { background:#fff; color:#000; font-family:Arial; text-align:center; margin:0; padding:0; }
  h1 { margin:20px; }
  #container { display:flex; justify-content:center; gap:20px; }
  .canvas-container { display:flex; flex-direction:column; align-items:center; }
  canvas { border:1px solid #ccc; background:#fff; }
  button { margin-top:10px; padding:8px 15px; }
</style>
</head>
<body>

<h1>Spectrum & Spectrogram Visualizer</h1>

<div id="container">
  <div class="canvas-container">
    <canvas id="spectrumCanvas" width="500" height="500"></canvas>
    <button id="downloadSpectrumBtn">Download Spectrum + Audio (1s)</button>
  </div>

  <div class="canvas-container">
    <canvas id="spectrogramCanvas" width="500" height="500"></canvas>
    <button id="downloadSpectrogramBtn">Download Spectrogram + Audio (10s)</button>
  </div>
</div>

<script>
/* -------------------------------------------------------
   CANVASES
-------------------------------------------------------- */
const spectrumCanvas = document.getElementById("spectrumCanvas");
const spectrumCtx = spectrumCanvas.getContext("2d");
const spectrogramCanvas = document.getElementById("spectrogramCanvas");
const spectrogramCtx = spectrogramCanvas.getContext("2d");

let audioCtx;
let analyser;
let sampleRate;

let audioBufferL = [];
let audioBufferR = [];

const AUDIO_BUFFER_SECONDS = 12;  // store slightly more than 10 sec

// ---- FOR FORMANT TRACKING ----
let formantFrames = [];   // stores [F1, F2, F3...] for each column

function storeFormantFrame(Fs) {
    formantFrames.push(Fs);
    if (formantFrames.length > FRAMES_NEEDED) {
        formantFrames.shift();
    }
}

/* -------------------------------------------------------
   SPECTROGRAM BUFFERING (10 SECONDS)
-------------------------------------------------------- */
const SPECTROGRAM_SECONDS = 10;
const SPECTROGRAM_WIDTH = spectrogramCanvas.width;   // e.g. 500 px
const FRAMES_NEEDED = SPECTROGRAM_WIDTH;             // 1 pixel column per frame
let spectrogramFrames = [];

/* Store one frequency column */
function saveForSpectrogram(dataArray, maxBin) {
    const col = new Uint8Array(maxBin);
    for (let i = 0; i < maxBin; i++) col[i] = dataArray[i];

    spectrogramFrames.push(col);

    if (spectrogramFrames.length > FRAMES_NEEDED) {
        spectrogramFrames.shift();
    }
}

/* -------------------------------------------------------
   AUDIO + ANALYZER SETUP
-------------------------------------------------------- */
navigator.mediaDevices.getUserMedia({ audio:true }).then(stream => {
    audioCtx = new AudioContext();
    sampleRate = audioCtx.sampleRate;

    const source = audioCtx.createMediaStreamSource(stream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;

    const processor = audioCtx.createScriptProcessor(4096, 2, 2);
    processor.onaudioprocess = e => {
        const L = e.inputBuffer.getChannelData(0);
        const R = e.inputBuffer.getChannelData(1);

        audioBufferL.push(...L);
        audioBufferR.push(...R);

        const maxSamples = AUDIO_BUFFER_SECONDS * sampleRate;
        if (audioBufferL.length > maxSamples) {
            audioBufferL = audioBufferL.slice(audioBufferL.length - maxSamples);
            audioBufferR = audioBufferR.slice(audioBufferR.length - maxSamples);
        }
    };

    source.connect(analyser);
    source.connect(processor);
    processor.connect(audioCtx.destination);

    const bufferLength = analyser.frequencyBinCount;
    const Nyquist = sampleRate / 2;
    const maxFreq = 2000;
    const maxBin = Math.floor(bufferLength * (maxFreq / Nyquist));
    const dataArray = new Uint8Array(bufferLength);

    // -------- SIMPLE FFT FORMANT ESTIMATOR (robust) --------
    function estimateFormantsFFT(dataArray, sampleRate, maxFreq) {
        const formants = [];
        const binToHz = (sampleRate / 2) / dataArray.length;

        for (let i = 2; i < dataArray.length - 2; i++) {
            const v = dataArray[i];

            if (v > dataArray[i - 1] &&
                v > dataArray[i + 1] &&
                v > 140) {               // threshold (tune if needed)
                
                const freq = i * binToHz;

                if (freq < maxFreq) {
                    formants.push(freq);
                }
            }
        }

        // pick the lowest formants: F1, F2, F3...
        // tried 5 but saw up to 3 in test so 5 for now
        formants.sort((a, b) => a - b);
        return formants.slice(0, 5);
    }

    function loop() {
        analyser.getByteFrequencyData(dataArray);

        const formants = estimateFormantsFFT(dataArray, sampleRate, maxFreq);
        storeFormantFrame(formants);
        window.currentFormants = formants;

        drawSpectrum(dataArray, maxBin, maxFreq);
        saveForSpectrogram(dataArray, maxBin);
        drawSpectrogram(maxFreq);

        requestAnimationFrame(loop);
    }

    loop();
});

/* -------------------------------------------------------
   WAV CREATION + AUDIO WINDOW
-------------------------------------------------------- */
function makeWav(left, right) {
    const length = left.length;
    const buffer = new ArrayBuffer(44 + length*4);
    const view = new DataView(buffer);

    function ws(o,s){ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); }

    ws(0,"RIFF");
    view.setUint32(4,36 + length*4,true);
    ws(8,"WAVE");
    ws(12,"fmt ");
    view.setUint32(16,16,true);
    view.setUint16(20,1,true);
    view.setUint16(22,2,true);
    view.setUint32(24,sampleRate,true);
    view.setUint32(28,sampleRate*4,true);
    view.setUint16(32,4,true);
    view.setUint16(34,16,true);
    ws(36,"data");
    view.setUint32(40,length*4,true);

    let off=44;
    for (let i=0;i<length;i++){
        view.setInt16(off, left[i]*32767, true); off+=2;
        view.setInt16(off, right[i]*32767, true); off+=2;
    }

    return new Blob([buffer], { type:"audio/wav" });
}

function getAudioWindow(seconds) {
    const samples = Math.floor(seconds * sampleRate);
    return makeWav(
        audioBufferL.slice(-samples),
        audioBufferR.slice(-samples)
    );
}

/* -------------------------------------------------------
   DOWNLOAD BUTTONS
-------------------------------------------------------- */
document.getElementById("downloadSpectrumBtn").onclick = () => {
    const img = document.createElement("a");
    img.download = "spectrum.png";
    img.href = spectrumCanvas.toDataURL();
    img.click();

    const wav = getAudioWindow(1);
    const a = document.createElement("a");
    a.download = "audio_1s.wav";
    a.href = URL.createObjectURL(wav);
    a.click();
};

document.getElementById("downloadSpectrogramBtn").onclick = () => {
    // CLEAR BUFFERS NOW
    spectrogramFrames = [];
    audioBufferL = [];
    audioBufferR = [];

    alert("Buffer cleared. Fresh 10 seconds will fill now. Downloading in 10 seconds...");

    setTimeout(() => {
        const img = document.createElement("a");
        img.download = "spectrogram.png";
        img.href = spectrogramCanvas.toDataURL();
        img.click();

        const wav = getAudioWindow(10);
        const a = document.createElement("a");
        a.download = "audio_10s.wav";
        a.href = URL.createObjectURL(wav);
        a.click();
    }, 10000);
};

/* -------------------------------------------------------
   SPECTRUM DRAWING (original)
-------------------------------------------------------- */
function drawSpectrum(dataArray, maxBin, maxFreq){
  const ctx = spectrumCtx;
  const width = spectrumCanvas.width;
  const height = spectrumCanvas.height;
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, width, height);

  const leftMargin = 70, bottomMargin = 50, topMargin = 40;
  const graphW = width - leftMargin - 20;
  const graphH = height - bottomMargin - topMargin;
  const originX = leftMargin;
  const originY = height - bottomMargin;

  ctx.strokeStyle = "#000";
  ctx.beginPath();
  ctx.moveTo(originX, originY);
  ctx.lineTo(originX+graphW, originY);
  ctx.moveTo(originX, originY);
  ctx.lineTo(originX, topMargin);
  ctx.stroke();

  ctx.font="12px Arial";
  ctx.fillStyle="#000";

  // x-axis
  const tickCount=5;
  for(let i=0;i<=tickCount;i++){
    const f = (i/tickCount)*maxFreq;
    const x = originX + (f/maxFreq)*graphW;
    ctx.beginPath();
    ctx.moveTo(x, originY);
    ctx.lineTo(x, originY+5);
    ctx.stroke();
    ctx.fillText(f.toFixed(0), x-15, originY+20);
  }
  ctx.fillText("Frequency (Hz)", leftMargin + graphW/2 - 20, topMargin + graphH + 40);

  // y-axis
  const yTicks=5;
  for(let i=0;i<=yTicks;i++){
    const val = (i/yTicks)*255;
    const y = originY - (i/yTicks)*graphH;
    ctx.beginPath();
    ctx.moveTo(originX-5, y);
    ctx.lineTo(originX, y);
    ctx.stroke();
    ctx.fillText(val.toFixed(0), originX-40, y+4);
  }

  ctx.save();
  ctx.translate(15, height/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Magnitude",0,0);
  ctx.restore();

  const barWidth = graphW / maxBin;
  for(let i=0;i<maxBin;i++){
    const barHeight = (dataArray[i]/255)*graphH;
    const x = originX + i*barWidth;
    const y = originY - barHeight;
    spectrumCtx.strokeRect(x, y, barWidth, barHeight);
  }

  // ------- DRAW FORMANT LINES ON SPECTRUM -------
  if (window.currentFormants) {
      spectrumCtx.strokeStyle = "red";
      spectrumCtx.lineWidth = 2;

      window.currentFormants.forEach(f => {
          const x = originX + (f / maxFreq) * graphW;

          spectrumCtx.beginPath();
          spectrumCtx.moveTo(x, topMargin);
          spectrumCtx.lineTo(x, originY);
          spectrumCtx.stroke();
      });
  }
}

/* -------------------------------------------------------
   SPECTROGRAM DRAWING (10s + AXIS LABELS)
-------------------------------------------------------- */
function drawSpectrogram(maxFreq){
  const ctx = spectrogramCtx;
  const width = spectrogramCanvas.width;
  const height = spectrogramCanvas.height;

  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,width,height);

  const leftMargin = 70, bottomMargin = 50, topMargin = 40;
  const graphW = width - leftMargin - 20;
  const graphH = height - bottomMargin - topMargin;
  const originX = leftMargin;
  const originY = height - bottomMargin;

  const frames = spectrogramFrames;
  const framesCount = frames.length;
  const maxBin = frames[0]?.length || 0;

  const pxW = graphW / FRAMES_NEEDED;
  const pxH = graphH / maxBin;

  // Draw only buffered frames (no fast scroll)
  for (let x = 0; x < framesCount; x++) {
    const col = frames[x];
    for (let y = 0; y < maxBin; y++) {
      const v = col[y] / 255;
      const intensity = 255 - Math.floor(v * 255);
      ctx.fillStyle = `rgb(${intensity},${intensity},${intensity})`;

      const px = leftMargin + x * pxW;
      const py = topMargin + graphH - y * pxH;
      ctx.fillRect(px, py, Math.ceil(pxW), Math.ceil(pxH));
    }
  }

  // axes
  ctx.strokeStyle="#000";
  ctx.beginPath();
  ctx.moveTo(leftMargin, topMargin);
  ctx.lineTo(leftMargin, topMargin + graphH);
  ctx.lineTo(leftMargin + graphW, topMargin + graphH);
  ctx.stroke();

  ctx.font = "12px Arial";
  ctx.fillStyle = "#000";

  // x-axis
  const tickCount=5;
  for(let i=0;i<=tickCount;i++){
    const f = (i/tickCount)*10;
    const x = originX + (f/10)*graphW;
    ctx.beginPath();
    ctx.moveTo(x, originY);
    ctx.lineTo(x, originY+5);
    ctx.stroke();
    ctx.fillText(f.toFixed(0), x-15, originY+20);
  }
  ctx.fillText("Time (s)", leftMargin + graphW/2 - 20, topMargin + graphH + 40);

  // y-axis
  const yTicks=5;
  for(let i=0;i<=yTicks;i++){
    const val = (i/yTicks)*2000;
    const y = originY - (i/yTicks)*graphH;
    ctx.beginPath();
    ctx.moveTo(originX-5, y);
    ctx.lineTo(originX, y);
    ctx.stroke();
    ctx.fillText(val.toFixed(0), originX-40, y+4);
  }

  ctx.save();
  ctx.translate(15, height/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Frequency (Hz)",0,0);
  ctx.restore();

  // ---- DRAW FORMANT LINES ----
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;

  for (let i = 0; i < formantFrames.length; i++) {
      const Fs = formantFrames[i];
      const x = leftMargin + (i / FRAMES_NEEDED) * graphW;

      ctx.beginPath();

      Fs.forEach(f => {
          const y = originY - (f / maxFreq) * graphH;
          ctx.moveTo(x, y);
          ctx.lineTo(x + 2, y);
      });

      ctx.stroke();
  }
  
}
</script>

</body>
</html>
