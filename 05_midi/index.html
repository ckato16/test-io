<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MIDI Piano Roll Trainer ðŸŽ¹</title>
<style>
body { font-family: sans-serif; background: #fff; text-align: center; margin: 0; padding: 0; overflow-x: hidden; }

#pianoWrapper {
  width: 100%;
  margin-top: 20px;
  overflow-x: visible;
  overflow-y: visible;
}

.scale-container {
  width: 100%;
  display: block;
  transform-origin: top left;
}

canvas {
  background: #fafafa;
  display: block;
  border:1px solid #aaa;
}

#keyboard {
  position: relative;
  width: 1750px;
  height: 200px;
  user-select: none;
}

.white-key {
  width: 40px;
  height: 200px;
  background: white;
  border:1px solid #000;
  position: absolute;
  cursor: pointer;
}
.white-key.active { background: red; }
.white-key.mic-active { background: orange !important; }

.black-key {
  width: 30px;
  height: 120px;
  background: black;
  position: absolute;
  top:0;
  z-index:2;
  cursor:pointer;
}
.black-key.active { background: red; }
.black-key.mic-active { background: orange !important; }

#scoreDisplay { margin-top: 10px; }

button, input, select { margin:5px; }
</style>
</head>
<body>

<h2>MIDI Piano Roll Trainer ðŸŽµ</h2>

<!-- ðŸŽ§ INPUT MODE SELECTOR -->
<label>Input Mode:
  <select id="inputMode">
    <option value="click">Click Only</option>
    <option value="audio">Audio (Microphone)</option>
    <option value="midi">MIDI Controller</option>
    <option value="all">All Inputs</option>
  </select>
</label>
<br>

<input type="file" id="midiFile" accept=".mid,.midi"/><br>
<button id="loadSample">Load sample</button>
<br>

<label>BPM: <input type="number" id="bpm" value="120" min="30" max="240"></label><br>

<button id="startBtn">Start</button>
<button id="stopBtn">Stop</button>
<button id="resetBtn">Reset</button>
<br>

<label>
  Position:
  <input type="range" id="seekSlider" min="0" max="1" step="0.0001" value="0" style="width:400px;">
</label>
<span id="timeLabel">0.00s</span>

<div id="scoreDisplay">Score: 0%</div>

<div id="pianoWrapper">
  <div id="scaleContainer" class="scale-container">
    <canvas id="pianoRoll" height="400"></canvas>
    <div id="keyboard"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.40/build/Tone.min.js"></script>

<script>
const canvas = document.getElementById('pianoRoll');
const ctx = canvas.getContext('2d');

const keyboardDiv = document.getElementById('keyboard');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');
const bpmInput = document.getElementById('bpm');
const seekSlider = document.getElementById("seekSlider");
const timeLabel = document.getElementById("timeLabel");
const inputModeSelect = document.getElementById("inputMode");

const startMidiNote = 24;
const endMidiNote = 96;
const whiteKeyWidth = 40;
const blackKeyWidth = 30;

let midiNotes = [];
let activeNotes = {};
let startTime = null;
let running = false;

let totalNotes = 0;
let hitNotes = 0;
let totalSongTime = 0;

let manualOffset = 0;
let useManualSeek = false;

let synth = new Tone.Synth().toDestination();

/* INPUT MODE HANDLER */
function allowInput(type) {
  const mode = inputModeSelect.value;
  return (mode === type || mode === "all");
}

/* SCORE */
function updateScore() {
  const score = totalNotes ? (hitNotes / totalNotes) * 100 : 0;
  document.getElementById("scoreDisplay").innerText = "Score: " + score.toFixed(1) + "%";
}

/* KEYBOARD CREATION */
const keys = [];
let whiteIndex = 0;

for (let i=startMidiNote; i<=endMidiNote; i++) {
  const noteName = Tone.Frequency(i,"midi").toNote();
  const isBlack = noteName.includes('#');
  let key;

  if (!isBlack) {
    key = document.createElement('div');
    key.className = 'white-key';
    key.style.left = (whiteIndex * whiteKeyWidth) + 'px';

    const label = document.createElement("div");
    label.style.position = "absolute";
    label.style.bottom = "5px";
    label.style.width = "100%";
    label.style.textAlign = "center";
    label.innerText = noteName;
    key.appendChild(label);
    whiteIndex++;
  } else {
    key = document.createElement('div');
    key.className = 'black-key';
    key.style.left = (whiteIndex * whiteKeyWidth - blackKeyWidth/2) + 'px';
  }

  key.dataset.note = i;

  key.onmousedown = ()=> { if (allowInput("click")) playSound(i, true); };
  key.onmouseup   = ()=> { if (allowInput("click")) playSound(i, false); };

  keyboardDiv.appendChild(key);
  keys.push({note:i, element:key, isBlack});
}

function getKeyX(note) {
  const k = keys.find(k=>k.note === note);
  return k ? parseFloat(k.element.style.left) : 0;
}
const numWhiteKeys = keys.filter(k => !k.isBlack).length;
canvas.width = numWhiteKeys * whiteKeyWidth;

/* AUDIO MIC SETUP */
let audioContext = null;
let analyser = null;
let microphone = null;
let dataArray = null;

async function enableMicIfNeeded() {
  if (!allowInput("audio")) return;
  if (audioContext) return; // already running

  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  microphone = audioContext.createMediaStreamSource(stream);

  analyser = audioContext.createAnalyser();
  analyser.fftSize = 2048;

  microphone.connect(analyser);
  dataArray = new Float32Array(analyser.fftSize);

  detectPitch();
}

inputModeSelect.onchange = () => {
  if (allowInput("audio")) enableMicIfNeeded();
};

function detectPitch() {
  requestAnimationFrame(detectPitch);

  if (!allowInput("audio") || !analyser) return;

  analyser.getFloatTimeDomainData(dataArray);
  const freq = autoCorrelate(dataArray, audioContext.sampleRate);

  keys.forEach(k => k.element.classList.remove("mic-active"));

  if (freq !== -1) {
    const midi = Math.round(69 + 12 * Math.log2(freq / 440));
    const key = keys.find(k => k.note === midi)?.element;
    if (key) key.classList.add("mic-active");

    checkMicNoteHit(midi);
  }
}

function autoCorrelate(buffer, sampleRate) {
  let SIZE = buffer.length;
  let rms = 0;

  for (let i=0; i<SIZE; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms/SIZE);
  if (rms < 0.01) return -1;

  let r1 = 0, r2 = SIZE-1;
  while (Math.abs(buffer[r1])<0.02 && r1<SIZE) r1++;
  while (Math.abs(buffer[r2])<0.02 && r2>0) r2--;

  buffer = buffer.slice(r1,r2);
  SIZE = buffer.length;

  let c = new Array(SIZE).fill(0);
  for (let i=0;i<SIZE;i++){
    for (let j=0;j<SIZE-i;j++){
      c[i] += buffer[j]*buffer[j+i];
    }
  }

  let d=0;
  while (c[d] > c[d+1]) d++;

  let maxval=-1, maxpos=-1;
  for (let i=d;i<SIZE;i++){
    if (c[i]>maxval){ maxval=c[i]; maxpos=i; }
  }

  let T0 = maxpos;
  return T0 ? sampleRate/T0 : -1;
}

function checkMicNoteHit(midi) {
  const now = currentTime();
  const targetLine = canvas.height - 10;

  for (let n of midiNotes) {
    if (n.hit) continue;
    if (n.noteNumber === midi) {
      const speed = getFallSpeed();
      const h = n.duration * speed;
      const y = (now - n.time) * speed - h;

      if (y + h >= targetLine && y <= targetLine) {
        n.hit = true;
        hitNotes++;
        updateScore();
        break;
      }
    }
  }
}

/* MIDI CONTROLLER INPUT */
navigator.requestMIDIAccess().then(midi => {
  for (const input of midi.inputs.values()) {
    input.onmidimessage = msg => {
      if (!allowInput("midi")) return;
      const [status, note, velocity] = msg.data;
      const cmd = status & 0xf0;

      if (cmd === 0x90 && velocity > 0) playSound(note, true);
      if (cmd === 0x80 || (cmd === 0x90 && velocity === 0)) playSound(note, false);
    };
  }
});

/* SOUND + SCORING */
function playSound(note, pressed){
  const key = keys.find(k => k.note === note)?.element;

  if (pressed) {
    synth.triggerAttack(Tone.Frequency(note,"midi"));
    activeNotes[note] = performance.now();
    if (key) key.classList.add("active");

    const now = currentTime();
    const targetLine = canvas.height - 10;

    for (let n of midiNotes) {
      if (n.hit) continue;
      if (n.noteNumber === note) {
        const speed = getFallSpeed();
        const h = n.duration * speed;
        const y = (now - n.time) * speed - h;
        if (y + h >= targetLine && y <= targetLine) {
          n.hit = true;
          hitNotes++;
          updateScore();
          break;
        }
      }
    }
  } else {
    synth.triggerRelease();
    delete activeNotes[note];
    if (key) key.classList.remove("active");
  }
}

/* MIDI LOAD */
document.getElementById('midiFile').addEventListener('change', async e=>{
  const file = e.target.files[0];
  if (!file) return;

  const arrayBuffer = await file.arrayBuffer();
  const midi = new Midi(arrayBuffer);

  midiNotes = [];
  midi.tracks.forEach(track=>{
    track.notes.forEach(n=>{
      midiNotes.push({ noteNumber:n.midi, time:n.time, duration:n.duration });
    });
  });

  midiNotes.sort((a,b)=>a.time-b.time);
  totalSongTime = computeSongEnd();

  totalNotes = midiNotes.length;
  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  seekSlider.value = 0;
  manualOffset = 0;

  alert("âœ… MIDI loaded! Click Start to play.");
});

/* SAMPLE LOAD */
document.getElementById("loadSample").onclick = () => {
  const q = 0.5;
  const notes = [48,49,50,51,52];

  midiNotes = [];
  let t = 0;

  notes.forEach(n=>{
    midiNotes.push({ noteNumber:n, time:t, duration:q });
    t += q;
  });

  totalSongTime = computeSongEnd();
  totalNotes = midiNotes.length;
  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  seekSlider.value = 0;
  manualOffset = 0;

  alert("ðŸŽµ Sample loaded! Press Start.");
};

function computeSongEnd() {
  const speed = getFallSpeed();
  let maxTime = 0;

  midiNotes.forEach(n => {
    const end = n.time + n.duration + (canvas.height / speed);
    if (end > maxTime) maxTime = end;
  });

  return maxTime;
}

/* CONTROLS */
startBtn.onclick = ()=>{
  if (!midiNotes.length) return alert("Load MIDI or sample first!");
  startTime = performance.now() - manualOffset * 1000;
  running = true;
};

stopBtn.onclick = ()=> running = false;

resetBtn.onclick = () => {
  running = false;

  hitNotes = 0;
  midiNotes.forEach(n => n.hit = false);
  updateScore();

  manualOffset = 0;
  seekSlider.value = 0;
  timeLabel.textContent = "0.00s";

  useManualSeek = true;
  draw();
  useManualSeek = false;
};

function currentTime() {
  let t;
  if (!running) t = manualOffset;
  else if (useManualSeek) t = manualOffset;
  else t = (performance.now() - startTime) / 1000;

  if (totalSongTime > 0)
    t = Math.min(t, totalSongTime);
  return t;
}

function getFallSpeed(){
  return 150 * (parseFloat(bpmInput.value) / 120);
}

/* SEEK SLIDER */
seekSlider.oninput = () => {
  if (!totalSongTime) return;
  useManualSeek = true;
  manualOffset = parseFloat(seekSlider.value) * totalSongTime;
  timeLabel.textContent = manualOffset.toFixed(2) + "s";
};

seekSlider.onchange = () => {
  startTime = performance.now() - manualOffset * 1000;
  useManualSeek = false;
};

/* DRAW LOOP */
function getKeyWidth(note) {
  const k = keys.find(k => k.note === note);
  return k ? (k.isBlack ? blackKeyWidth : whiteKeyWidth) : 20;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const now = currentTime();
  if (running && now >= totalSongTime) {
    running = false;
    manualOffset = totalSongTime;
    seekSlider.value = 1;
    timeLabel.textContent = totalSongTime.toFixed(2) + "s";
  }

  const speed = getFallSpeed();
  const targetLine = canvas.height - 10;

  for (let n of midiNotes) {
    const x = getKeyX(n.noteNumber);
    const width = getKeyWidth(n.noteNumber);
    const h = n.duration * speed;
    const y = (now - n.time) * speed - h;

    if (y < targetLine) {
      ctx.fillStyle = n.hit ? "green" : "red";
      ctx.fillRect(x, y, width, h);
    }
  }

  if (running && totalSongTime > 0 && !useManualSeek) {
    const t = currentTime();
    seekSlider.value = Math.min(1, t / totalSongTime);
    timeLabel.textContent = t.toFixed(2) + "s";
  }

  requestAnimationFrame(draw);
}
draw();

/* RESPONSIVE SCALING */
function resizeScale() {
  const baseWidth = 1750;
  const screenWidth = window.innerWidth;
  const scale = screenWidth / baseWidth;

  const scaleContainer = document.getElementById("scaleContainer");
  scaleContainer.style.transform = `scale(${scale})`;
  scaleContainer.style.width = baseWidth + "px";
}

window.addEventListener("resize", resizeScale);
resizeScale();
</script>

</body>
</html>
